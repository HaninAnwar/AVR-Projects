/***********************************************************************/
/***********************************************************************/
/************************ AUTHER : Hanin Anwar  ************************/
/************************ LAYER  : MCAL         ************************/
/************************ SWC    : ADC          ************************/
/************************ VERSION : 1.00         ************************/
/***********************************************************************/
/***********************************************************************/

#include "STD_TYPES.h"
#include "BIT_MATH.h"

#include "ADC_register.h"
#include "ADC_config.h"
#include "ADC_private.h"
#include "ADC_interface.h"

static u16 *ADC_p16Reading = NULL;
static void (*ADC_pvCallBackNotificationFunc(void)) = NULL;

void ADC_voidInit(void)
{

	/*1. check reference voltage*/
#if ADC_REF_VOLT == AREF
	CLR_BIT(ADMUX,ADCMUX_REFS0);
	CLR_BIT(ADMUX,ADCMUX_REFS1);

#elif ADC_REF_VOLT == AVCC
	SET_BIT(ADMUX,ADCMUX_REFS0);
	CLR_BIT(ADMUX,ADCMUX_REFS1);

#elif ADC_REF_VOLT == INTERNAL_VOLT
	SET_BIT(ADMUX,ADCMUX_REFS0);
	SET_BIT(ADMUX,ADCMUX_REFS1);

#else
#error "Wrong ADC_REF_VOLT configuration option"

#endif


	/*2. check ADC adjust*/
#if ADC_RESOLUTION == EIGHT_BITS
	SET_BIT(ADMUX,ADCMUX_ADLAR);

#elif ADC_RESOLUTION == TEN_BITS
	CLR_BIT(ADMUX,ADCMUX_ADLAR);

#else
#error "Wrong ADC_ADJUST configuration option"

#endif

	/*3. Set selected prescaler using bit masking*/
	ADCSRA &= PRESCALING_MASK; //Clear prescaler bits
	ADCSRA |= ADC_PRESCALER;

	/*4. Check auto trigger enable*/
#if ADC_AUTO_TRIGGER_EN == ENABLED
	SET_BIT(ADCSRA,ADCSRA_ADATE);

	/*Set ADC interrupt source*/
	SFIOR &= TRIGGER_SRC_MASK;
	SFIOR |= ADC_TRIGGER_SRC;


#elif ADC_AUTO_TRIGGER_EN == DISABLED
	CLR_BIT(ADCSRA,ADCSRA_ADIE);
	CLR_BIT(ADCSRA,ADCSRA_ADATE);

#else
#error "Wrong ADC_AUTO_TRIGGER_EN configuration option"

#endif

	/*5. Check ADC interrupt enable*/
#if ADC_INT_EN == ENABLED
	SET_BIT(ADCSRA,ADCSRA_ADIE);

#elif ADC_INT_EN == DISABLED
	CLR_BIT(ADCSRA,ADCSRA_ADIE);

#else
#error "Wrong ADC_INT_EN configuration option"

#endif

	/*6. Set selected trigger source*/
	SFIOR &= TRIGGER_SRC_MASK;
	SFIOR |= (ADC_TRIGGER_SRC << 5);

	/*7. Check peripheral enable*/
#if ADC_ENABLE == ENABLED
	SET_BIT(ADCSRA,ADCSRA_ADEN);

#elif ADC_ENABLE == DISABLED
	CLR_BIT(ADCSRA,ADCSRA_ADEN);

#else
#error "Wrong ADC_ENABLE configuration option"

#endif
}

u8 ADC_u8StartConversionSynch(u8 Copy_u8Channel , u16 *Copy_p16Reading)
{
	u8 Local_u8ErrorState = OK;
	u32 Local_u32Counter = 0;
	/*Clear MUX bits in ADMUX register */
	ADMUX &= MUX_MASK;

	/*Set the selected channel into MUX bits*/
	ADMUX |= Copy_u8Channel;

	/*Start Conversion*/
	SET_BIT(ADCSRA,ADCSRA_ADSC);


	/*Polling (busy waiting) until the conversion complete flag is risen OR Counter reaching timeout*/
	while(((GET_BIT(ADCSRA,ADCSRA_ADIF))==0) && (Local_u32Counter != ADC_u32TIME_OUT))
	{
		Local_u32Counter++;
	}

	if(Local_u32Counter == ADC_u32TIME_OUT)
	{
		/*Loop is broken because timeout is reached*/
		Local_u8ErrorState = NOK;
	}

	else
	{
		/*Loop is broken because flag is risen*/

		/*Clear the conversion complete flag*/
		SET_BIT(ADCSRA,ADCSRA_ADIF);

#if ADC_RESOLUTION == TEN_BITS
		*Copy_p16Reading = ADC_2BYTES;

#elif ADC_RESOLUTION == EIGHT_BITS
		*Copy_p16Reading = ADCH;

#else
#error "Wrong ADC_USED_BITS configuration option"

#endif

	}

	return Local_u8ErrorState;
}

u8 ADC_u8StartConversionAsynch(u8 Copy_u8Channel , u16 *Copy_p16Reading , void (*Copy_pvNotificationFunc(void)))
{
	u8 Local_u8ErrorState = OK;

	if((Copy_p16Reading == NULL) || (Copy_pvNotificationFunc == NULL))
	{
		Local_u8ErrorState = NULL_POINTER;
	}

	else
	{
		/*Initialize Reading variable globally*/
		ADC_p16Reading = Copy_p16Reading;

		/*Initialize callback notification function globally*/
		ADC_pvCallBackNotificationFunc = Copy_pvNotificationFunc;

		/*Clear MUX bits in ADMUX register */
		ADMUX &= MUX_MASK;

		/*Set the selected channel into MUX bits*/
		ADMUX |= Copy_u8Channel;

		/*Start Conversion*/
		SET_BIT(ADCSRA,ADCSRA_ADSC);

		/*ADC interrupt enable*/
		SET_BIT(ADCSRA,ADCSRA_ADIE);


	}
	return Local_u8ErrorState;
}

void __vector_16 (void) __attribute__((signal));
void __vectot_16(void)
{
	/*Reading ADC result*/
	if(ADC_RESOLUTION == TEN_BITS)
	{
		*ADC_p16Reading = ADC_2BYTES;
	}

	else if(ADC_RESOLUTION == EIGHT_BITS)
	{
		*ADC_p16Reading = ADCH;
	}

	if(ADC_pvCallBackNotificationFunc != NULL)
	{
		ADC_pvCallBackNotificationFunc();
	}
}
